/*
题意：n个数，前k个数必须错排，问方案数
记f[i][j]为直接的答案，f[i][j]=f[i][j-1]-f[i-1][j-1];
错排公式为dp[i]=(i-1)*(dp[i-1]+dp[i-2])，首先选择某个位置k放第i个数，然后如果k放n，那么就是dp[i-2]，否则k不能放到n，
其他数约束不变，相当i-1个数的错排。
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int maxn=18;

ll a[maxn],f[maxn][maxn];
void init()
{
    a[0]=1;
    for(int i=1;i<maxn;i++)a[i]=i*a[i-1];
    for(int i=0;i<maxn;i++)f[i][0]=a[i];
    for(int i=1;i<maxn;i++)
        for(int j=1;j<=i;j++)
            f[i][j]=f[i][j-1]-f[i-1][j-1];
}

int main()
{
    //freopen("ACM/in.in","r",stdin);
    init();
    int cas,n,m;
    int T;
    scanf("%d",&T);
    while(T--)
    {
       scanf("%d%d%d",&cas,&n,&m);
       printf("%d %lld\n",cas,f[n][m]);
    }
    return 0;
}
