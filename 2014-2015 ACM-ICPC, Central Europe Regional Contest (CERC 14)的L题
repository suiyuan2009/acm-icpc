/*
题意：给出怪兽的开始和结束时间，以及杀死所需要的能量，求杀死所有的最少花费
错误解法：按右端点排序，记f[i][j]为到前i个怪兽被杀，包含i的右端点的怪兽杀了j个(按花费排)的最优
1
5
5 7 10
8 9 4
7 10 4
3 7 3
1 5 10
*/
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn = 305;

int n;
struct P {
    int x,y,z;
    P() {}
    P(int x,int y,int z):x(x),y(y),z(z) {}
    bool operator<(const P&a)const {
        return y==a.y?x<a.x:y<a.y;
    }
} p[maxn];
vector<int>e[maxn];

int cur;
bool cmp(int x,int y) {
    if(x==cur)return 1;
    if(y==cur)return 0;
    return p[x].z<p[y].z;
}

int f[maxn][maxn];

void init() {
    scanf("%d",&n);
    for(int i=1; i<=n; i++) {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        p[i]=P(x,y,z);
        e[i].clear();
    }
    sort(p+1,p+n+1);
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++)
            if(p[j].x<=p[i].y&&p[i].y<=p[j].y)e[i].push_back(j);
        cur=i;
        sort(e[i].begin(),e[i].end(),cmp);
    }
    memset(f,-1,sizeof(f));
    f[0][0]=0;
}

bool vis[maxn];

void pd(int&ret,int val) {
    if(ret==-1||ret>val)ret=val;
}

int main() {
    //freopen("in.cpp","r",stdin);
    //freopen("out2.cpp","w",stdout);
    e[0].push_back(maxn-1);
    int T;
    scanf("%d",&T);
    while(T--) {
        init();
        for(int i=0; i<n; i++) {
            memset(vis,0,sizeof(vis));
            for(int j=0; j<e[i].size(); j++) {
                if(f[i][j]==-1)continue;
                vis[e[i][j]]=1;
                int mx=0;
                for(int k=0; k<e[i+1].size(); k++) {
                    if(!vis[e[i+1][k]])mx=max(mx,p[e[i+1][k]].z);
                    //if(i==1&&j==0&&k==1)printf("** %d %d %d\n",mx,f[i][j],e[i+1][k]);
                    pd(f[i+1][k],f[i][j]+mx);
                }
            }
        }
        //printf("** %d\n",f[1][1]);
        //printf("**%d %d: %d\n",p[2].x,p[2].y,f[2][0]);
        printf("%d\n",f[n][e[n].size()-1]);
    }
    return 0;
}
