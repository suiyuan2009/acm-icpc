-/*
 -题意：
 -Given n boxes with widths of w1; w2; : : : ; wn and another big box with width W, nd how many ways
 -the boxes can be put in the big box. The constrains are:
 -1) Of course the summation of widths of the placed boxes should not be greater than W.
 -2) The boxes should be placed one by one starting from left without leaving any empty spaces
 -between them. So, the end of the big box may contain empty spaces. But if there is any unplaced
 -box which can be t in this space, the ordering should be considered invalid (See the explanation
 -for sample case 1).
 -3) Two orderings are considered dierent if in one ordering, one box is in i-th position, but in another
 -ordering, it isn't.
 -4) If two boxes have same widths, they should be considered same.
 -
 -记f[i][j][k]为到第i个物品（预处理出相同宽度的物品集合），
 -前i-1类物品中选了j个且第i+1到第m类物品中必须选出总长是k的方案数。
 -物品先sort，枚举到第几类物品时开始出现没选全的情况，累和。
 -*/
 -#include <cstdio>
 -#include <cstring>
 -#include <algorithm>
 -#include <iostream>
 -using namespace std;
 -const int maxn=105;
 -const int maxm=1005;
 -const int mod=10007;
 -
 -int n,W,w[maxn],a[maxn],b[maxn],m;
 -int f[maxn][maxn][maxm];
 -bool vis[maxn][maxn][maxm];
 -int c[maxn][maxn];
 -
 -int dfs(int x,int y,int z)
 -{
 -    if(x==m+1)return z==0;
 -    if(vis[x][y][z])return f[x][y][z];
 -    int ret=0;
 -    for(int i=0; i<=b[x]; i++)
 -    {
 -        if(z-i*a[x]<0)break;
 -        ret=(ret+dfs(x+1,y+i,z-i*a[x])*c[y+i][i]%mod)%mod;
 -    }
 -    vis[x][y][z]=1;
 -    return f[x][y][z]=ret;
 -}
 -
 -void init()
 -{
 -    for(int i=0; i<maxn; i++)c[i][0]=c[i][i]=1;
 -    for(int i=1; i<maxn; i++)
 -        for(int j=1; j<i; j++)
 -            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
 -    sort(w+1,w+n+1);
 -    m=0;
 -    for(int i=1; i<=n; i++)
 -    {
 -        int j=i;
 -        while(j+1<=n&&w[j+1]==w[i])j++;
 -        a[++m]=w[i];
 -        b[m]=j-i+1;
 -        i=j;
 -    }
 -    memset(f,0,sizeof(f));
 -    memset(vis,0,sizeof(vis));
 -}
 -
 -int main()
 -{
 -    int T,ncase=0;
 -    scanf("%d",&T);
 -    while(T--)
 -    {
 -        scanf("%d%d",&n,&W);
 -        for(int i=1; i<=n; i++)
 -            scanf("%d",&w[i]);
 -        init();
 -
 -        //for(int i=1;i<=m;i++)
 -        // printf("** %d: %d %d\n",i,a[i],b[i]);
 -
 -        int ret=0;
 -        int cnt=0,sum=0,tt=1;
 -        for(int i=1; i<=m; i++)
 -        {
 -            for(int j=0; j<b[i]; j++)
 -            {
 -                int left=W-sum-j*a[i];
 -                if(left<0)break;
 -                for(int k=0; k<a[i]; k++)
 -                {
 -                    if(left-k<0)break;
 -                    ret=(ret+dfs(i+1,cnt+j,left-k)*c[cnt+j][j]%mod*tt%mod)%mod;
 -                }
 -            }
 -            cnt+=b[i];
 -            tt=tt*c[cnt][b[i]]%mod;
 -            sum+=a[i]*b[i];
 -        }
 -        if(sum<=W)ret=(ret+tt)%mod;
 -        printf("Case %d: %d\n",++ncase,ret);
 -    }
 -    return 0;
 -}
